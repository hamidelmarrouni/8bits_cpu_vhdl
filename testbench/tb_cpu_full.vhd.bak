library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.constants_pkg.all;

entity tb_cpu_full is
end entity;

architecture sim of tb_cpu_full is

    signal clk   : std_logic := '0';
    signal rst_n : std_logic := '0';

    constant T : time := 10 ns;

    -- Memory programming interface
    signal prog_addr : std_logic_vector(ADDR_W-1 downto 0);
    signal prog_data : std_logic_vector(DATA_W-1 downto 0);
    signal prog_we   : std_logic := '0';

    -- CPU <-> Memory wires
    signal mem_addr  : std_logic_vector(ADDR_W-1 downto 0);
    signal mem_dout  : std_logic_vector(DATA_W-1 downto 0);
    signal mem_din   : std_logic_vector(DATA_W-1 downto 0);
    signal mem_rd    : std_logic;
    signal mem_wr    : std_logic;
    signal mem_ready : std_logic;

begin
    --------------------------------------------------------------------
    -- CLOCK
    --------------------------------------------------------------------
    clk <= not clk after T/2;


    --------------------------------------------------------------------
    -- Instantiate memory separately
    --------------------------------------------------------------------
    memory_inst : entity work.memory
        port map(
            clk   => clk,
            addr  => mem_addr,
            dout  => mem_dout,
            din   => mem_din,
            rd    => mem_rd,
            wr    => mem_wr,
            ready => mem_ready
        );

    --------------------------------------------------------------------
    -- Instantiate CPU top
    --------------------------------------------------------------------
    uut : entity work.cpu_top
        port map(
            clk   => clk,
            rst_n => rst_n
        );

    --------------------------------------------------------------------
    -- CONNECT CPU TO MEMORY
    -- (Modify cpu_top.vhd so it exposes these signals if needed)
    --------------------------------------------------------------------
    mem_addr <= uut.s_mem_addr;
    mem_dout <= uut.s_bus_data;
    mem_rd   <= uut.c_mem_rd;
    mem_wr   <= uut.c_mem_wr;


    --------------------------------------------------------------------
    -- TASK-LIKE PROCEDURE TO WRITE IN MEMORY
    --------------------------------------------------------------------
    write_to_mem : process
    begin
        -- Keep reset high while we preload memory
        rst_n <= '0';
        wait for 50 ns;

        report "Preloading program into memory..." severity note;

        ----------------------------------------------------------------
        -- PROGRAM PAYLOAD
        ----------------------------------------------------------------

        -- LDI R0, #10
        mem_addr <= std_logic_vector(to_unsigned(0, ADDR_W));
        mem_dout <= x"10"; mem_wr <= '1'; wait for T; mem_wr <= '0';

        mem_addr <= std_logic_vector(to_unsigned(1, ADDR_W));
        mem_dout <= x"0A"; mem_wr <= '1'; wait for T; mem_wr <= '0';

        -- LDI R1, #05
        mem_addr <= std_logic_vector(to_unsigned(2, ADDR_W));
        mem_dout <= x"12"; mem_wr <= '1'; wait for T; mem_wr <= '0';

        mem_addr <= std_logic_vector(to_unsigned(3, ADDR_W));
        mem_dout <= x"05"; mem_wr <= '1'; wait for T; mem_wr <= '0';

        -- ADD R0, R1
        mem_addr <= std_logic_vector(to_unsigned(4, ADDR_W));
        mem_dout <= x"20"; mem_wr <= '1'; wait for T; mem_wr <= '0';

        mem_addr <= std_logic_vector(to_unsigned(5, ADDR_W));
        mem_dout <= x"01"; mem_wr <= '1'; wait for T; mem_wr <= '0';

        -- SUB R0, R1
        mem_addr <= std_logic_vector(to_unsigned(6, ADDR_W));
        mem_dout <= x"30"; mem_wr <= '1'; wait for T; mem_wr <= '0';

        mem_addr <= std_logic_vector(to_unsigned(7, ADDR_W));
        mem_dout <= x"01"; mem_wr <= '1'; wait for T; mem_wr <= '0';

        -- XOR R0, R1
        mem_addr <= std_logic_vector(to_unsigned(8, ADDR_W));
        mem_dout <= x"60"; mem_wr <= '1'; wait for T; mem_wr <= '0';

        mem_addr <= std_logic_vector(to_unsigned(9, ADDR_W));
        mem_dout <= x"01"; mem_wr <= '1'; wait for T; mem_wr <= '0';

        -- ST [20], R0
        mem_addr <= std_logic_vector(to_unsigned(10, ADDR_W));
        mem_dout <= x"80"; mem_wr <= '1'; wait for T; mem_wr <= '0';

        mem_addr <= std_logic_vector(to_unsigned(11, ADDR_W));
        mem_dout <= x"14"; mem_wr <= '1'; wait for T; mem_wr <= '0';

        -- LD R2, [20]
        mem_addr <= std_logic_vector(to_unsigned(12, ADDR_W));
        mem_dout <= x"27"; mem_wr <= '1'; wait for T; mem_wr <= '0';

        mem_addr <= std_logic_vector(to_unsigned(13, ADDR_W));
        mem_dout <= x"14"; mem_wr <= '1'; wait for T; mem_wr <= '0';

        -- BRZ +2
        mem_addr <= std_logic_vector(to_unsigned(14, ADDR_W));
        mem_dout <= x"90"; mem_wr <= '1'; wait for T; mem_wr <= '0';

        mem_addr <= std_logic_vector(to_unsigned(15, ADDR_W));
        mem_dout <= x"02"; mem_wr <= '1'; wait for T; mem_wr <= '0';

        -- LDI R3, #FF
        mem_addr <= std_logic_vector(to_unsigned(16, ADDR_W));
        mem_dout <= x"1A"; mem_wr <= '1'; wait for T; mem_wr <= '0';

        mem_addr <= std_logic_vector(to_unsigned(17, ADDR_W));
        mem_dout <= x"FF"; mem_wr <= '1'; wait for T; mem_wr <= '0';

        -- JMP 0
        mem_addr <= std_logic_vector(to_unsigned(18, ADDR_W));
        mem_dout <= x"A0"; mem_wr <= '1'; wait for T; mem_wr <= '0';

        mem_addr <= std_logic_vector(to_unsigned(19, ADDR_W));
        mem_dout <= x"00"; mem_wr <= '1'; wait for T; mem_wr <= '0';


        ----------------------------------------------------------------
        -- RELEASE RESET AND START CPU
        ----------------------------------------------------------------
        wait for 20 ns;
        rst_n <= '1';

        report "CPU Running..." severity note;

        wait for 3000 ns;

        assert false
            report "CPU Testbench finished successfully."
            severity failure;

    end process;

end architecture;
